# Практика 5
## Пункты задания
1. Реализовать функции, аналогичные встроенным функциям sort,
sort!, sortperm, sortperm! на основе алгоритма сортировки вставками. При этом, при проектировании функциий, аналогичных функциям sort и sort!, требуется избежать повторного кодирования алгоритма сортировки. То же относится и к проектированию пары функций, аналогичных функциям sortperm, sortperm!

2. Реализовать алгоритм сортировки "расчесыванием", который базируется на сортировке "пузырьком". Исследовать эффективность этого алгоритма в равнении с пузырьковой сортировкой (на больших массивах делать времннные замеры).

3. Реализовать алгоритм сортировки Шелла, который базируется на сортировке вставками. Исследовать эффективность этого алгоритма в равнении с сортировкой вставками (на больших массивах делать времннные замеры).

4. Реализовать алгоритм сортировки слияниями. Исследовать эффективность этого алгоритма в сравнении с предыдущми алгоритмами.

5. Реализовать алгоритм сортировки Хоара. Исследовать эффективность этого алгоритма в сравнении с предыдущми алгоритмами.

6. Реализовать вычисление медианы массива на основе процедуры Хоара.

7. Реализовать алгоритм сортировки за линейное время.


## Сортировка Шелла

```julia
function shell_sort!(
    a; 
    step_series = (length(a)÷2^i for i in 1:Int(floor(log2(length(a))))) 
)
    for step in step_series
        for i in firstindex(a):lastindex(a)-step
            j = i
            while j >= firstindex(a) && a[j] > a[j+step]
                a[j], a[j+step] = a[j+step], a[j]
                j -= step
            end
        end
    end
    return a
end
```
Здесь последовательность шагов прореживания массива определяется генератором
`step_series = (length(a)÷2^i for i in 1:Int(floor(log2(length(a)))))`.

ЗАМЕЧАНИЕ. В приведенном коде можно было бы обойтись без внешнего задания последовательности шагов `step_series`. Это можно было бы сделать и в теле функции.

По-существу, то же самое (несколько изменив порядок сравнения пар) можно записать еще и так:

```julia
function shell_sort_alt!(a)
    n = length(a)
    step_series = (n÷2^i for i in 1:Int(floor(log2(n)))) 
    for step in step_series
        for i in firstindex(a):step-1
            insert_sort!(@view a[i:step:end]) # - сортировка вставками выделенного (прореженного) подмассива
        end
    end
    return a
end
```
Однако этот вариант алгоритма выполняется значительно медленнее предыдущего.

Объяснить это можно тем, что используемые здесь сылки на не плотные срезы не эффективны.

См. также https://ru.wikipedia.org/wiki/Сортировка_Шелла


## Алгоритм сортировки "расчесткой"

```julia  
function comb_sort!(a; factor=1.2473309)
    step = length(a)
    while step >= 1
        for i in 1:length(a)-step
            if a[i] > a[i+step]
                a[i], a[i+step] = a[i+step], a[i]
            end
        end
        step = Int(floor(step/factor))
    end
    # Теперь массив почти упорядочен, осталось сделать всего несколько итераций внешнего цикла в bubble_sort!(a)
    bubble_sort!(a)
end
```

См. также https://ru.wikipedia.org/wiki/Сортировка_расчёской