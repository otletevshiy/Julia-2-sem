# Практика 1
1. Написать функцию, вычисляющую НОД двух чисел (или многочленов)

Решение.
```julia
function gcd_(a::T, b::T) where T # - это означает, что тип обоих аргументов один и тот же
    # a0, b0 = a, b
    #ИНВАРИАНТ: НОД(a,b) = HОД(a0,b0)
    while !iszero(b) # - это условие более универсальное, чем b != 0 или b > 0. Функция iszero определена для всех числовых типов. Для пользовательских типов ее надо будет определять
        a, b = b, rem(a,b) # rem(a,b) - это то же самое, что и a % b (есть еще функция mod(a,b))
    end
    return abs(a) # т.к. используется функция rem, то a может получиться отризательным
end
```

2. Написать функцию, реализующую расширенный алгоритм Евклида, вычисляющий не только НОД, но и коэффициенты его линейного представления.

**Утверждение.** Пусть d=НОД(a, b), тогда существуют такие целые коэффициенты u, v, что d=u*a+v*b

Мы спроектируем расширенный алгоритм Евклида с помощью инварианта цикла, и тем самым будет доказаго это утверждение.

Напомним, что инвариантом цикла (с передусловием) называется некотрое утверждение относительно переменных, изменяющихся в цикле, которое справедливо как перед началом выполнения цикла, так и после любого числа его повторений.

В данном случае в качестве инварианта цикла возьмём утверждение 


```julia
function gcdx_(a::T, b::T) where T # - это означает, что тип обоих аргументов один и тот же
    # a0, b0 = a, b
    u, v = one(T), zero(T) # - универсальнее, чем 1, 0 и гарантирует стабильность типов переменных
    u_, v_ = v, u
    #ИНВАРИАНТ: НОД(a,b) = HОД(a0,b0) && a = u*a0 + v*b0 && b = u_*a0 + v_ * b0
    while !iszero(b) # - это условие более универсальное, чем b != 0 или b > 0. Функция iszero определена для всех числовых типов. Для пользовательских типов ее надо будет определять
        r, k = remdiv(a,b) # remdiv(a,b) возвращает кортеж из rem(a,b) и div(a,b)
        a, b = b, r #  r = a - k*b
        u, u_ = u_, u-k*u_ # эти преобразования переменных следуют из инварианта цикла
        v, v_ = v_, v-k*v_
    end
    if isnegarive(a) #  использование функции isnegative делает данный алгоритм более универсальным, но эту функцию требуется определить, в том числе и для целых типов
        a, u, v = -a, -u, -v
    end
    return a, u, v 
end

isnegative(a::Integer) = (a < 0)
```
Интересно исследовать, как реализована встроенная функция gcdx

Для этого надо открыть ее исходный код с помощью следующей команды

```julia
julia> edit(gcdx, (Integer, Integer))
```
В функциию edit всегда надо передавать саму функцию (исходный код которой интересует) и кортеж из типов её элементов.
3. С использованием функции gcdx_ реаализовать функцию invmod_(a::T, M::T) where T, которая бы возвращала бы обратное значение инвертируемого элемента (a) кольца вычетов по модулю M, а для необращаемых элементов возвращала бы nothing.

(если положить M=b  и если d = ua+vb, то при условии, что d=1, a^-1 = u, в противном случае элемент a не обратим)

4. С использованием функции gcdx_ реализовать функцию diaphant_solve(a::T,b::T,c::T) where T, которая бы возвращала решение дафаетового уравнения ax+by=c, если уравнение разрешимо, и значение nothing - в противном случае
   
(если d=ua+vb, и если получилость, что d=1, u, v - есть решение уравнения, в противном случае уранение не разрешимо)

5. Для вычислений в кольце вычетов по модулю M определить специальный тип
   
```julia
struct Rsidue{T,M}
    a::T
    Residue{T,M}(a)where{T,M} = new(mod(a, M))
end

и определить для этого типа следующие операци и функции:
+, -, унарный минус, *, ^, inverse (обращает обратимые элементы), display (определяет, в каком виде значение будет выводиться в REPL)

6. Реализовать тип Plolynom{T} (T- тип коэффициентов многочлена)

7. Обеспечить взаимодействие типов Residue{M} и Polynom{T}, т.е. добиться, чтобы можно было бы создавать кольцо вычетов многочленов (по заданному модулю) и чтобы можно было создавить многочлены с коэффициентами из кольца вычетов.

При создании кольца вычетов многочленов параеметр M должен принимать значение кортежа коэффициентов соответсвующего многочлена.